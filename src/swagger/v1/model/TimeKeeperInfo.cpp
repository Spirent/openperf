/**
* OpenPerf API
* REST API interface for OpenPerf
*
* OpenAPI spec version: 1
* Contact: support@spirent.com
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/


#include "TimeKeeperInfo.h"

namespace swagger {
namespace v1 {
namespace model {

TimeKeeperInfo::TimeKeeperInfo()
{
    m_Frequency = 0.0;
    m_FrequencyIsSet = false;
    m_Frequency_error = 0.0;
    m_Frequency_errorIsSet = false;
    m_Local_frequency = 0.0;
    m_Local_frequencyIsSet = false;
    m_Local_frequency_error = 0.0;
    m_Local_frequency_errorIsSet = false;
    m_Offset = 0.0;
    m_Synced = false;
    m_SyncedIsSet = false;
    m_Theta = 0.0;
    m_ThetaIsSet = false;
    
}

TimeKeeperInfo::~TimeKeeperInfo()
{
}

void TimeKeeperInfo::validate()
{
    // TODO: implement validation
}

nlohmann::json TimeKeeperInfo::toJson() const
{
    nlohmann::json val = nlohmann::json::object();

    if(m_FrequencyIsSet)
    {
        val["frequency"] = m_Frequency;
    }
    if(m_Frequency_errorIsSet)
    {
        val["frequency_error"] = m_Frequency_error;
    }
    if(m_Local_frequencyIsSet)
    {
        val["local_frequency"] = m_Local_frequency;
    }
    if(m_Local_frequency_errorIsSet)
    {
        val["local_frequency_error"] = m_Local_frequency_error;
    }
    val["offset"] = m_Offset;
    if(m_SyncedIsSet)
    {
        val["synced"] = m_Synced;
    }
    if(m_ThetaIsSet)
    {
        val["theta"] = m_Theta;
    }
    

    return val;
}

void TimeKeeperInfo::fromJson(nlohmann::json& val)
{
    if(val.find("frequency") != val.end())
    {
        setFrequency(val.at("frequency"));
    }
    if(val.find("frequency_error") != val.end())
    {
        setFrequencyError(val.at("frequency_error"));
    }
    if(val.find("local_frequency") != val.end())
    {
        setLocalFrequency(val.at("local_frequency"));
    }
    if(val.find("local_frequency_error") != val.end())
    {
        setLocalFrequencyError(val.at("local_frequency_error"));
    }
    setOffset(val.at("offset"));
    if(val.find("synced") != val.end())
    {
        setSynced(val.at("synced"));
    }
    if(val.find("theta") != val.end())
    {
        setTheta(val.at("theta"));
    }
    
}


double TimeKeeperInfo::getFrequency() const
{
    return m_Frequency;
}
void TimeKeeperInfo::setFrequency(double value)
{
    m_Frequency = value;
    m_FrequencyIsSet = true;
}
bool TimeKeeperInfo::frequencyIsSet() const
{
    return m_FrequencyIsSet;
}
void TimeKeeperInfo::unsetFrequency()
{
    m_FrequencyIsSet = false;
}
double TimeKeeperInfo::getFrequencyError() const
{
    return m_Frequency_error;
}
void TimeKeeperInfo::setFrequencyError(double value)
{
    m_Frequency_error = value;
    m_Frequency_errorIsSet = true;
}
bool TimeKeeperInfo::frequencyErrorIsSet() const
{
    return m_Frequency_errorIsSet;
}
void TimeKeeperInfo::unsetFrequency_error()
{
    m_Frequency_errorIsSet = false;
}
double TimeKeeperInfo::getLocalFrequency() const
{
    return m_Local_frequency;
}
void TimeKeeperInfo::setLocalFrequency(double value)
{
    m_Local_frequency = value;
    m_Local_frequencyIsSet = true;
}
bool TimeKeeperInfo::localFrequencyIsSet() const
{
    return m_Local_frequencyIsSet;
}
void TimeKeeperInfo::unsetLocal_frequency()
{
    m_Local_frequencyIsSet = false;
}
double TimeKeeperInfo::getLocalFrequencyError() const
{
    return m_Local_frequency_error;
}
void TimeKeeperInfo::setLocalFrequencyError(double value)
{
    m_Local_frequency_error = value;
    m_Local_frequency_errorIsSet = true;
}
bool TimeKeeperInfo::localFrequencyErrorIsSet() const
{
    return m_Local_frequency_errorIsSet;
}
void TimeKeeperInfo::unsetLocal_frequency_error()
{
    m_Local_frequency_errorIsSet = false;
}
double TimeKeeperInfo::getOffset() const
{
    return m_Offset;
}
void TimeKeeperInfo::setOffset(double value)
{
    m_Offset = value;
    
}
bool TimeKeeperInfo::isSynced() const
{
    return m_Synced;
}
void TimeKeeperInfo::setSynced(bool value)
{
    m_Synced = value;
    m_SyncedIsSet = true;
}
bool TimeKeeperInfo::syncedIsSet() const
{
    return m_SyncedIsSet;
}
void TimeKeeperInfo::unsetSynced()
{
    m_SyncedIsSet = false;
}
double TimeKeeperInfo::getTheta() const
{
    return m_Theta;
}
void TimeKeeperInfo::setTheta(double value)
{
    m_Theta = value;
    m_ThetaIsSet = true;
}
bool TimeKeeperInfo::thetaIsSet() const
{
    return m_ThetaIsSet;
}
void TimeKeeperInfo::unsetTheta()
{
    m_ThetaIsSet = false;
}

}
}
}

