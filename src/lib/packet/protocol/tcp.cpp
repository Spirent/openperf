/**
 * tcp implementation for the packet header C++ Library
 *
 * This file is automatically generated by the library code generator.
 * Do not edit this file manually.
 **/

#include "tcp.hpp"

namespace libpacket::protocol {

/**
 * tcp getter implementations
 **/

uint16_t get_tcp_source(const tcp& header) noexcept
{
    return (header.source.load());
}

uint16_t get_tcp_destination(const tcp& header) noexcept
{
    return (header.destination.load());
}

uint32_t get_tcp_sequence(const tcp& header) noexcept
{
    return (header.sequence.load());
}

uint32_t get_tcp_ack(const tcp& header) noexcept
{
    return (header.ack.load());
}

uint16_t get_tcp_data_offset(const tcp& header) noexcept
{
    auto tmp = header.data_offset_reserved_flags.load<uint16_t>() & 0xf000;
    tmp >>= 12;
    tmp *= 4;
    return (tmp);
}

uint16_t get_tcp_reserved(const tcp& header) noexcept
{
    auto tmp = header.data_offset_reserved_flags.load<uint16_t>() & 0xe00;
    tmp >>= 9;
    return (tmp);
}

type::bit_flags<tcp::flags_value> get_tcp_flags(const tcp& header) noexcept
{
    auto tmp = header.data_offset_reserved_flags.load<uint16_t>() & 0x1ff;
    return (static_cast<type::bit_flags<tcp::flags_value>>(tmp));
}

uint16_t get_tcp_window(const tcp& header) noexcept
{
    return (header.window.load());
}

uint16_t get_tcp_checksum(const tcp& header) noexcept
{
    auto tmp = header.checksum.load<uint16_t>();
    return (tmp);
}

uint16_t get_tcp_urgent_pointer(const tcp& header) noexcept
{
    auto tmp = header.urgent_pointer.load<uint16_t>();
    return (tmp);
}

/**
 * tcp setter implementations
 **/

void set_tcp_source(tcp& header, uint16_t value) noexcept
{
    header.source = value;
}

void set_tcp_destination(tcp& header, uint16_t value) noexcept
{
    header.destination = value;
}

void set_tcp_sequence(tcp& header, uint32_t value) noexcept
{
    header.sequence = value;
}

void set_tcp_ack(tcp& header, uint32_t value) noexcept
{
    header.ack = value;
}

void set_tcp_data_offset(tcp& header, uint16_t value) noexcept
{
    value /= 4;
    value <<= 12;
    header.data_offset_reserved_flags.store(static_cast<uint16_t>(((value & 0xf000) | (header.data_offset_reserved_flags.load<uint16_t>() & ~0xf000))));
}

void set_tcp_reserved(tcp& header, uint16_t value) noexcept
{
    value <<= 9;
    header.data_offset_reserved_flags.store(static_cast<uint16_t>(((value & 0xe00) | (header.data_offset_reserved_flags.load<uint16_t>() & ~0xe00))));
}

void set_tcp_flags(tcp& header, type::bit_flags<tcp::flags_value> value) noexcept
{
    auto tmp = static_cast<uint16_t>(value.value);
    header.data_offset_reserved_flags.store(static_cast<uint16_t>(((tmp & 0x1ff) | (header.data_offset_reserved_flags.load<uint16_t>() & ~0x1ff))));
}

void set_tcp_window(tcp& header, uint16_t value) noexcept
{
    header.window = value;
}

void set_tcp_checksum(tcp& header, uint16_t value) noexcept
{
    header.checksum.store(value);
}

void set_tcp_urgent_pointer(tcp& header, uint16_t value) noexcept
{
    header.urgent_pointer.store(value);
}

/**
 * tcp field translate implementation
 **/

template <typename Key, typename Value, typename... Pairs>
constexpr auto associative_array(Pairs&&... pairs)
    -> std::array<std::pair<Key, Value>, sizeof... (pairs)>
{
    return {{std::forward<Pairs>(pairs)...}};
}

enum tcp::field_name tcp::get_field_name(std::string_view name) noexcept
{
    constexpr auto field_names = associative_array<std::string_view, tcp::field_name>(
        std::pair("source", tcp::field_name::source),
        std::pair("destination", tcp::field_name::destination),
        std::pair("sequence", tcp::field_name::sequence),
        std::pair("ack", tcp::field_name::ack),
        std::pair("data_offset", tcp::field_name::data_offset),
        std::pair("reserved", tcp::field_name::reserved),
        std::pair("flags", tcp::field_name::flags),
        std::pair("window", tcp::field_name::window),
        std::pair("checksum", tcp::field_name::checksum),
        std::pair("urgent_pointer", tcp::field_name::urgent_pointer));

    auto cursor = std::begin(field_names), end = std::end(field_names);
    while (cursor != end) {
        if (cursor->first == name) return (cursor->second);
        cursor++;
    }

    return (tcp::field_name::none);
}

const std::type_info& tcp::get_field_type(tcp::field_name field) noexcept
{
    switch (field) {
        case tcp::field_name::source:
            return (typeid(uint16_t));
        case tcp::field_name::destination:
            return (typeid(uint16_t));
        case tcp::field_name::sequence:
            return (typeid(uint32_t));
        case tcp::field_name::ack:
            return (typeid(uint32_t));
        case tcp::field_name::data_offset:
            return (typeid(uint16_t));
        case tcp::field_name::reserved:
            return (typeid(uint16_t));
        case tcp::field_name::flags:
            return (typeid(uint16_t));
        case tcp::field_name::window:
            return (typeid(uint16_t));
        case tcp::field_name::checksum:
            return (typeid(uint16_t));
        case tcp::field_name::urgent_pointer:
            return (typeid(uint16_t));
        default:
            return (typeid(nullptr));
    }
}

}
