/**
 * MPLS implementation for the packet header C++ Library
 *
 * This file is automatically generated by the library code generator.
 * Do not edit this file manually.
 **/

#include "mpls.hpp"

namespace libpacket::protocol {

/**
 * MPLS getter implementations
 **/

uint32_t get_mpls_label(const mpls& header) noexcept
{
    auto tmp = header.label_traffic_class_bottom_of_stack.load<uint32_t>() & 0xfffff0;
    tmp >>= 4;
    return (tmp);
}

uint32_t get_mpls_traffic_class(const mpls& header) noexcept
{
    auto tmp = header.label_traffic_class_bottom_of_stack.load<uint32_t>() & 0xe;
    tmp >>= 1;
    return (tmp);
}

bool get_mpls_bottom_of_stack(const mpls& header) noexcept
{
    auto tmp = header.label_traffic_class_bottom_of_stack.load<uint32_t>() & 0x1;
    return (static_cast<bool>(tmp));
}

uint8_t get_mpls_ttl(const mpls& header) noexcept
{
    return (header.ttl.load());
}

/**
 * MPLS setter implementations
 **/

void set_mpls_label(mpls& header, uint32_t value) noexcept
{
    value <<= 4;
    header.label_traffic_class_bottom_of_stack.store(static_cast<uint32_t>(((value & 0xfffff0) | (header.label_traffic_class_bottom_of_stack.load<uint32_t>() & ~0xfffff0))));
}

void set_mpls_traffic_class(mpls& header, uint32_t value) noexcept
{
    value <<= 1;
    header.label_traffic_class_bottom_of_stack.store(static_cast<uint32_t>(((value & 0xe) | (header.label_traffic_class_bottom_of_stack.load<uint32_t>() & ~0xe))));
}

void set_mpls_bottom_of_stack(mpls& header, bool value) noexcept
{
    auto tmp = static_cast<uint32_t>(value);
    header.label_traffic_class_bottom_of_stack.store(static_cast<uint32_t>(((tmp & 0x1) | (header.label_traffic_class_bottom_of_stack.load<uint32_t>() & ~0x1))));
}

void set_mpls_ttl(mpls& header, uint8_t value) noexcept
{
    header.ttl = value;
}

/**
 * MPLS field translate implementation
 **/

template <typename Key, typename Value, typename... Pairs>
constexpr auto associative_array(Pairs&&... pairs)
    -> std::array<std::pair<Key, Value>, sizeof... (pairs)>
{
    return {{std::forward<Pairs>(pairs)...}};
}

enum mpls::field_name mpls::get_field_name(std::string_view name) noexcept
{
    constexpr auto field_names = associative_array<std::string_view, mpls::field_name>(
        std::pair("label", mpls::field_name::label),
        std::pair("traffic_class", mpls::field_name::traffic_class),
        std::pair("bottom_of_stack", mpls::field_name::bottom_of_stack),
        std::pair("ttl", mpls::field_name::ttl));

    auto cursor = std::begin(field_names), end = std::end(field_names);
    while (cursor != end) {
        if (cursor->first == name) return (cursor->second);
        cursor++;
    }

    return (mpls::field_name::none);
}

const std::type_info& mpls::get_field_type(mpls::field_name field) noexcept
{
    switch (field) {
        case mpls::field_name::label:
            return (typeid(uint32_t));
        case mpls::field_name::traffic_class:
            return (typeid(uint32_t));
        case mpls::field_name::bottom_of_stack:
            return (typeid(uint32_t));
        case mpls::field_name::ttl:
            return (typeid(uint8_t));
        default:
            return (typeid(nullptr));
    }
}

}
