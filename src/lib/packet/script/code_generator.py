import argparse
import re
import os
import pathlib
import sys
import textwrap
import yaml

HEADER_GUARD="_LIB_PACKET_PROTOCOL_{}_HPP_"
HEADER_NAMESPACE="packet::protocol"
INCLUDE_BASE_DIR="packet/type"


def write_file_header(output, name, kind):
    header='''
    /**
     * {name} {kind} for the packet header C++ Library
     *
     * This file is automatically generated by the library code generator.
     * Do not edit this file manually.
     **/
    '''

    output.write(textwrap.dedent(header.format(name=name,kind=kind)).lstrip())


def write_comment(output, text):
    wrapper = textwrap.TextWrapper(initial_indent=" * ")

    output.write('/**\n')
    for line in wrapper.wrap(text):
        output.write(line)
    output.write('\n **/\n\n')


def write_cr(output, count=None):
    repeat = count if count else 1
    output.write('\n'*repeat)


def to_cpp_name(name):
    return name.lower()


class cpp_namespace():
    def __init__(self, output, ns):
        self.output = output
        self.ns = ns

    def __enter__(self):
        self.output.write('namespace {} {{\n'.format(self.ns))
        write_cr(self.output)
        return self.output

    def __exit__(self, type, value, traceback):
        write_cr(self.output)
        self.output.write('}\n')


class cpp_header_guard():
    def __init__(self, output, name):
        self.guard = HEADER_GUARD.format(name.upper())
        self.output = output

    def __enter__(self):
        self.output.write('#ifndef {}\n'.format(self.guard))
        self.output.write('#define {}\n'.format(self.guard))
        write_cr(self.output)
        return self.output

    def __exit__(self, type, value, traceback):
        write_cr(self.output)
        self.output.write('#endif /* {} */\n'.format(self.guard))


def get_length_in_bits(field):
    fmt = field['format'] if 'format' in field else 'field'

    if fmt == 'field' or fmt == 'enumeration' or fmt == 'number':
        return (field['length'])
    elif fmt == 'ipv4':
        return 32
    elif fmt == 'mac':
        return 48
    elif fmt == 'ipv6':
        return 128

    assert False, 'Unrecognized format'


def make_field_mask(offset, nb_bits, width):
    assert offset + nb_bits <= width

    mask = 0

    for i in range(offset, width):
        if i - offset < nb_bits:
            mask |= 1 << (width - (i + 1))

    return mask


def octets_to_unsigned_int_type(octets):
    assert octets <= 8

    if octets <= 1:
        return ('uint8_t')
    if octets <= 2:
        return ('uint16_t')
    if octets <= 4:
        return ('uint32_t')
    return ('uint64_t')


def field_to_unsigned_int_type(field):
    return octets_to_unsigned_int_type(int(re.match('.+endian::field<(\d+)>', field).group(1)))


def get_cpp_type(name, props, nb_bits):
    fmt = props['format'] if 'format' in props else 'field'

    if fmt == 'field' or fmt == 'enumeration':
        assert nb_bits % 8 == 0, 'Number of bits must be a multiple of 8'
        return 'type::endian::field<{:d}>'.format(nb_bits // 8)
    if fmt == 'number':
        assert nb_bits % 8 == 0, 'Number of bits must be a multiple of 8'
        assert nb_bits <= 64, 'Number of bits exceeds machine type'
        return 'type::endian::number<{}>'.format(octets_to_unsigned_int_type(nb_bits // 8))
    elif fmt == 'ipv4':
        return 'type::ipv4_address'
    elif fmt == 'ipv6':
        return 'type::ipv6_address'
    elif fmt == 'mac':
        return 'type::mac_address'

    assert False, 'Unrecognized format'


def get_cpp_function_type(struct, field, props):
    if 'values' in props:
        if props['values']['unique']:
            return 'enum {}::{}_value'.format(struct, field)
        else:
            return 'type::bit_flags<{}::{}_value>'.format(struct, field)

    cpp_type = props['cpp_type']

    match = re.match('type::endian::field<(\d+)>', cpp_type)
    if match:
        return 'bool' if props['length'] == 1 else octets_to_unsigned_int_type(int(match.group(1)))
    #return octets_to_unsigned_int_type(int(match.group(1)))

    match = re.match('type::endian::number<(\w+)>', cpp_type)
    if match:
        return match.group(1)

    return 'const {}&'.format(props['cpp_type'])


def get_getter_declaration(struct, field, props):
    return '{0} get_{1}_{2}(const {1}& header) noexcept'.format(
        get_cpp_function_type(struct, field, props),
        struct,
        field)


def is_reference(cpp_type):
    return cpp_type.endswith('&')


def to_lvalue(ref_type):
    assert is_reference(ref_type), 'must be reference type'

    base_type = re.search('(const)?\s+(.*)&', ref_type).group(2).strip();
    return '{}&&'.format(base_type)


def is_lvalue(cpp_type):
    return cpp_type.endswith('&&')


def needs_cast(cpp_type):
    if cpp_type.find('bit_flags') >= 0:
        return True
    if cpp_type.find('enum') >= 0:
        return True
    if cpp_type.find('bool') >= 0:
        return True

    return False


def is_number(cpp_type):
    return cpp_type.find('endian::number') >= 0


def get_setter_declaration(struct, field, arg_type):
    return ('void set_{0}_{1}({0}& header, {2} value) noexcept'.format(
        struct, field, arg_type))


def generate_field_data(fields):
    out_fields = dict()

    loop_fields = dict()
    for name, values in fields.items():
        loop_fields[name] = values
        loop_bits = sum(get_length_in_bits(v) for v in loop_fields.values())
        if loop_bits % 8 != 0:
            continue

        # If combining fields, make sure all fields have the same type
        formats = set(map(lambda v: v['format'] if 'format' in v else 'field', loop_fields.values()))
        if 'number' in formats and len(formats) > 1:
            sys.stderr.write('Combined fields ({}) cannot contain a numeric field\n'.format(
                ', '.join(loop_fields.keys())))
            sys.exit(1)

        loop_name = '_'.join(loop_fields.keys())
        offset = 0
        for name, props in loop_fields.items():
            field_bits = get_length_in_bits(props)
            out_fields[name] = {
                'length': field_bits,
                'struct_name': loop_name,
                'cpp_type': get_cpp_type(name, props, loop_bits),
            }

            if 'multipleOf' in props:
                out_fields[name]['multipleOf'] = props['multipleOf']

            if 'items' in props:
                value_tuples = list()
                for item in props['items']:
                    value_tuples.append(next(iter(item.items())))

                out_fields[name]['values'] = {
                    'items': value_tuples,
                    'unique': props['uniqueItems'] if 'uniqueItems' in props else False
                }

            if (len(loop_fields.keys()) > 1):
                out_fields[name]['mask'] = make_field_mask(offset, field_bits, loop_bits)
                out_fields[name]['shift'] = loop_bits - field_bits - offset

            offset += field_bits
        loop_fields = dict()

    return out_fields


def get_struct_tuples(field_data):
    tuples = list()
    for props in field_data.values():
        x = (props['cpp_type'], props['struct_name'])
        if x not in tuples:
            tuples.append(x)

    return (tuples)


def get_includes(data):
    headers = set()
    for props in data.values():
        cpp_type = props['cpp_type']
        addr_match = re.match('(\w+)::(\w+)_address', cpp_type)
        if addr_match:
            headers.add(os.path.join(INCLUDE_BASE_DIR,
                                     '{}_address.hpp'.format(addr_match.group(2))))
        elif cpp_type.find('endian') >= 0:
            if 'values' in props and not props['values']['unique']:
                headers.add(os.path.join(INCLUDE_BASE_DIR,
                                         'enum_flags.hpp'))
            headers.add(os.path.join(INCLUDE_BASE_DIR, 'endian.hpp'))
        else:
            assert False, 'unhandled cpp type: {}'.format(cpp_type)

    return sorted(headers)


"""
C++ header writing functions
"""

def write_header_struct(output, name, data):
    output.write('struct {}\n'.format(name))
    output.write('{\n')

    # Store the length of this struct
    output.write('    static constexpr uint16_t protocol_length = {};\n'.format(
        sum(field['length'] for field in data.values()) // 8
    ))

    # Generate any enums we might need
    for field, props in data.items():
        if 'values' in props:
            output.write('\n');
            output.write('    enum class {}_value\n'.format(field))
            output.write('    {\n')
            for enum, value in props['values']['items']:
                output.write('        {} = 0x{:x},\n'.format(enum, value))
            output.write('    };\n')

    output.write('\n')
    for kind, name in get_struct_tuples(data):
        output.write('    {} {};\n'.format(kind, name))
    output.write('};\n')


def write_cpp_header_contents(output, name, data):
    cpp_name = to_cpp_name(name)
    write_header_struct(output, cpp_name, data)
    write_cr(output)

    write_comment(output, '{} get functions'.format(name))

    for field, props in data.items():
        output.write('{};\n'.format(get_getter_declaration(cpp_name, field, props)))

    write_cr(output)
    write_comment(output, '{} set functions'.format(name))

    for field, props in data.items():
        arg_type = get_cpp_function_type(cpp_name, field, props)
        output.write('{};\n'.format(get_setter_declaration(cpp_name, field, arg_type)))

        if is_reference(arg_type):
            output.write('{};\n'.format(get_setter_declaration(cpp_name, field, to_lvalue(arg_type))))


def maybe_write_enum_declaration(output, name, data):
    cpp_name = to_cpp_name(name)
    enums = list(filter(lambda item: 'values' in item[1] and not item[1]['values']['unique'],
                        data.items()))
    if len(enums):
        write_cr(output)
        for name, props in enums:
            output.write('declare_enum_flags({}::{}::{}_value);\n'.format(
                HEADER_NAMESPACE, cpp_name, name
            ))

"""
C++ implementation writing functions
"""

def generate_getter_impl(output, struct, field, props):
    return_type = get_cpp_function_type(struct, field, props)

    output.write('{}\n'.format(get_getter_declaration(struct, field, props)))
    output.write('{\n')

    if is_reference(return_type):
        output.write('    return (header.{});\n'.format(props['struct_name']))
    elif is_number(props['cpp_type']):
        output.write('    return (header.{}.load());\n'.format(props['struct_name'], return_type))
    else:
        if needs_cast(return_type):
            to_load = field_to_unsigned_int_type(props['cpp_type'])
        else:
            to_load = return_type

        if 'mask' in props:
            output.write('    auto tmp = header.{}.load<{}>() & 0x{:x};\n'.format(
                props['struct_name'], to_load, props['mask']))

            if 'shift' in props and props['shift']:
                output.write('    tmp >>= {};\n'.format(props['shift']))
        else:
            output.write('    auto tmp = header.{}.load<{}>();\n'.format(props['struct_name'], to_load))

        if 'multipleOf' in props:
            output.write('    tmp *= {};\n'.format(props['multipleOf']))

        if needs_cast(return_type):
            output.write('    return (static_cast<{}>(tmp));\n'.format(return_type))
        else:
            output.write('    return (tmp);\n')

    output.write('}\n')


def generate_setter_impl(output, struct, field, props, arg_type):
    output.write('{}\n'.format(get_setter_declaration(struct, field, arg_type)))
    output.write('{\n')

    if is_lvalue(arg_type):
        output.write('    set_{0}_{1}(header, value);\n'.format(struct, field))
    elif is_reference(arg_type) or is_number(props['cpp_type']):
        output.write('    header.{} = value;\n'.format(props['struct_name']))
    else:
        var_name = 'value'
        int_type = field_to_unsigned_int_type(props['cpp_type'])

        if needs_cast(arg_type):
            if arg_type.find('bit_flag') >= 0:
                var_name = 'value.value'
            output.write('    auto tmp = static_cast<{}>({});\n'.format(int_type, var_name))
            var_name = 'tmp'

        if 'multipleOf' in props:
            output.write('    {} /= {};\n'.format(var_name, props['multipleOf']))

        if 'mask' in props:
            if 'shift' in props and props['shift']:
                output.write('    {} <<= {};\n'.format(var_name, props['shift']))

            output.write('    header.{0}.store(static_cast<{2}>((({3} & 0x{1:x}) | (header.{0}.load<{2}>() & ~0x{1:x}))));\n'.format(
                props['struct_name'], props['mask'],
                field_to_unsigned_int_type(props['cpp_type']), var_name))
        else:
            output.write('    header.{}.store({});\n'.format(props['struct_name'], var_name))

    output.write('}\n')


def generate_getters(struct, data):
    for field, props in data.items():
        generate_getter(struct, field, props)


def generate_setters(output, struct, field, props):
    arg_type = get_cpp_function_type(struct, field, props)
    generate_setter_impl(output, struct, field, props, arg_type)

    if is_reference(arg_type):
        write_cr(output)
        generate_setter_impl(output, struct, field, props, to_lvalue(arg_type))


def write_cpp_implementation_contents(output, name, data):
    cpp_name = to_cpp_name(name)
    skip_cr = True

    write_comment(output, '{} getter implementations'.format(name))

    for field, props in data.items():
        generate_getter_impl(output, cpp_name, field, props)
        write_cr(output)

    write_comment(output, '{} setter implementations'.format(name))

    nb_items = len(data.items())
    for idx, (field, props) in enumerate(data.items()):
        generate_setters(output, cpp_name, field, props)
        if idx + 1 < nb_items:
            write_cr(output)


"""
Top level implementation functions
"""

def write_cpp_header(output, name, fields):
    cpp_name = to_cpp_name(name)
    data = generate_field_data(fields)

    with cpp_header_guard(output, cpp_name):
        write_file_header(output, name, 'header')
        write_cr(output)

        for include in get_includes(data):
            output.write('#include "{}"\n'.format(include))
        write_cr(output)

        with cpp_namespace(output, HEADER_NAMESPACE):
            write_cpp_header_contents(output, name, data)

        maybe_write_enum_declaration(output, name, data)


def write_cpp_implementation(output, name, fields, header):
    cpp_name = to_cpp_name(name)
    data = generate_field_data(fields)

    write_file_header(output, name, 'implementation')
    write_cr(output)

    output.write('#include "{}"\n'.format(header))
    write_cr(output)

    with cpp_namespace(output, HEADER_NAMESPACE):
        write_cpp_implementation_contents(output, name, data)


"""
Begin script proper
"""

def main():
    parser = argparse.ArgumentParser(description="Generate C++ headers from yaml definitions")
    parser.add_argument('--infile',
                        nargs='?',
                        type=argparse.FileType('r'),
                        default=sys.stdin,
                        help="input YAML file containing header definition")
    parser.add_argument('--outdir',
                        nargs='?',
                        type=pathlib.Path,
                        default=os.getcwd(),
                        help="output directory to write generated files")

    args = parser.parse_args()

    if not os.path.isdir(args.outdir):
        sys.stderr.write('Output directory, {}, does not exist\n'.format(args.outdir))
        sys.exit(1)

    if not os.access(args.outdir, os.W_OK):
        sys.stderr.write('Output directory, {}, is not writable\n'.format(args.outdir))
        sys.exit(1)

    obj = yaml.load(args.infile, Loader=yaml.FullLoader)

    for name, data in obj.items():
        file_root = to_cpp_name(name)
        header = file_root + '.hpp'

        fields = data['fields']

        with open(os.path.join(args.outdir, header), 'w') as header_out:
            write_cpp_header(header_out, name, fields)

        with open(os.path.join(args.outdir, file_root + '.cpp'), 'w') as impl_out:
            write_cpp_implementation(impl_out, name, fields, header)


if __name__ == "__main__":
    main()
