import argparse
import fnmatch
import os
import pathlib
import sys
import textwrap
import yaml

def write_header(output):
    header='''
    ###
    # This file is automatically generated by {}.  Do not edit!
    ###
    '''

    output.write(textwrap.dedent(header.format(os.path.basename(__file__))).lstrip())
    output.write('\n')


def to_ipv4(proto, field, data):
    prop = {
        'type': 'string',
        'description': 'IPv4 {} address'.format(field),
        'pattern': '^((25[0-5]|2[0-4][0-9]|[01]?[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|[01]?[1-9]?[0-9])$'
    }

    if 'default' in data:
        prop['default'] = data['default']

    return prop


def to_ipv6(proto, field, data):
    prop = {
        'type': 'string',
        'description': 'IPv6 {} address'.format(field),
        'pattern': '^((::[0-9a-fA-F]{1,4})|([0-9a-fA-F]{1,4}::)|(([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F])|(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}))$'
    }

    if 'default' in data:
        prop['default'] = data['default']

    return prop


def to_mac(proto, field, data):
    prop = {
        'type': 'string',
        'description': 'Ethernet MAC {} address'.format(field),
        'pattern': '^([0-9a-fA-F]{1,2}(.|-|:)){5}[0-9a-fA-F]{1,2}$'
    }

    if 'default' in data:
        prop['default'] = data['default']

    return prop


def to_description(proto, field, data):
    if 'description' in data:
        return data['description']
    else:
        return '{} {}'.format(proto, field).translate(str.maketrans('_', ' '))


def to_bool(proto, field, data):
    prop = {
        'type': 'boolean',
        'description': to_description(proto, field, data)
    }

    return prop


def to_number(proto, field, data):
    length = int(data['length'])
    if length == 1:
        return to_bool(proto, field, data)

    max_value = int(pow(2, length)) - 1
    if 'multipleOf' in data:
        max_value *= int(data['multipleOf'])

    prop = {
        'type': 'integer',
        'description': to_description(proto, field, data),
        'format': 'int32' if data['length'] < 32 else 'int64',
        'minimum': 0,
        'maximum': max_value
    }

    if 'default' in data:
        prop['default'] = int(data['default'])

    if 'multipleOf' in data:
        prop['multipleOf'] = int(data['multipleOf'])

    return prop


def to_enumeration_items(proto, field, data):
    return [next(iter(t)) for t in data['items']]


def to_enumeration(proto, field, data):
    if 'uniqueItems' in data:
        prop = {
            'type': 'string',
            'description': to_description(proto, field, data),
            'enum': to_enumeration_items(proto, field, data)
        }
    else:
        prop = {
            'type': 'array',
            'description': to_description(proto, field, data),
            'items': {
                'enum': to_enumeration_items(proto, field, data),
                'type': 'string'
            }
        }

    if 'default' in data:
        prop['default'] = data['default']

    return prop


def dummy(field):
    return dict()


def to_property(proto, field, data):
    format_dispatch = {
        'ipv4': to_ipv4,
        'ipv6': to_ipv6,
        'mac': to_mac,
        'number': to_number,
        'enumeration': to_enumeration
    }

    prop = dict()
    if 'format' in data and data['format'] in format_dispatch:
        prop.update(format_dispatch[data['format']](proto, field, data))
    else:
        prop.update(to_number(proto, field, data))


    return prop


def translate_fields(proto, blob):
    properties = dict()
    for field, props in blob.items():
        properties[field] = to_property(proto, field, props)

    return properties


def to_swagger_name(name):
    return 'PacketProtocol{}'.format(name.lower().capitalize())


"""
Begin script proper
"""


def main():
    parser = argparse.ArgumentParser(
        description="Generate swagger protocol specification from YAML definitions")
    parser.add_argument('--indir',
                        nargs='?',
                        type=pathlib.Path,
                        default=os.getcwd(),
                        help="input directory containing YAML definitions")
    parser.add_argument('--outfile',
                        nargs='?',
                        type=argparse.FileType('w'),
                        default=sys.stdout,
                        help="output swagger definition")

    args = parser.parse_args()

    if not os.path.isdir(args.indir):
        sys.stderr.write('Input directory, {}, does not exist\n'.format(args.indir))
        sys.exit(1)

    if not os.access(args.indir, os.R_OK):
        sys.stderr.write('Input directory, {}, is not readable\n'.format(args.indir))
        sys.exit(1)

    definitions = dict()
    for yaml_file in filter(lambda f: fnmatch.fnmatch(f, '*.yaml'), os.listdir(args.indir)):
        with open(os.path.join(args.indir, yaml_file), 'r') as f:
            for name, data in yaml.load(f, Loader=yaml.FullLoader).items():
                definitions[name] = data

    swagger = dict()

    for name, data in definitions.items():
        swagger_name = to_swagger_name(name)
        swagger[swagger_name] = {
            'type': 'object',
            'description': 'Describes {} {} header'.format(
                'an' if name.lower()[0] in 'aeio' else 'a',
                name),
        }
        swagger[swagger_name]['properties'] = translate_fields(name, data['fields'])

    write_header(args.outfile)
    args.outfile.write(yaml.dump({'definitions': swagger}))


if __name__ == "__main__":
    main()
