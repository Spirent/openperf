/**
 * swagger <-> libpacket transmogrify implementation for IPv4
 *
 * This file is automatically generated by the transmogrify code generator.
 * Do not edit this file manually.
 **/

#include "ipv4.hpp"

namespace openperf::packet::protocol::transmogrify {

std::shared_ptr<swagger::v1::model::PacketProtocolIpv4> to_swagger(libpacket::protocol::ipv4& src)
{
    auto dst = std::make_shared<swagger::v1::model::PacketProtocolIpv4>();

    dst->setVersion(get_ipv4_version(src));
    dst->setHeaderLength(get_ipv4_header_length(src));
    dst->setDscp(get_ipv4_dscp(src));
    
    switch(auto ecn_value = get_ipv4_ecn(src)) {
    case libpacket::protocol::ipv4::ecn_value::non_ect:
        dst->setEcn("non_ect");
        break;
    case libpacket::protocol::ipv4::ecn_value::ect_0:
        dst->setEcn("ect_0");
        break;
    case libpacket::protocol::ipv4::ecn_value::ect_1:
        dst->setEcn("ect_1");
        break;
    case libpacket::protocol::ipv4::ecn_value::ce:
        dst->setEcn("ce");
        break;
    }
    
    dst->setTotalLength(get_ipv4_total_length(src));
    dst->setIdentification(get_ipv4_identification(src));
    
    auto src_flags = get_ipv4_flags(src);
    if (src_flags & libpacket::protocol::ipv4::flags_value::evil_bit)
    {
        dst->getFlags().emplace_back("evil_bit");
    }
    if (src_flags & libpacket::protocol::ipv4::flags_value::dont_fragment)
    {
        dst->getFlags().emplace_back("dont_fragment");
    }
    if (src_flags & libpacket::protocol::ipv4::flags_value::more_fragments)
    {
        dst->getFlags().emplace_back("more_fragments");
    }
    
    dst->setFragmentOffset(get_ipv4_fragment_offset(src));
    dst->setTimeToLive(get_ipv4_time_to_live(src));
    dst->setProtocol(get_ipv4_protocol(src));
    dst->setChecksum(get_ipv4_checksum(src));
    dst->setSource(to_string(get_ipv4_source(src)));
    dst->setDestination(to_string(get_ipv4_destination(src)));

    return (dst);
}

static enum libpacket::protocol::ipv4::ecn_value to_ipv4_ecn(std::string_view value)
{
    if (value == "non_ect")
    {
        return (libpacket::protocol::ipv4::ecn_value::non_ect);
    }
    else if (value == "ect_0")
    {
        return (libpacket::protocol::ipv4::ecn_value::ect_0);
    }
    else if (value == "ect_1")
    {
        return (libpacket::protocol::ipv4::ecn_value::ect_1);
    }
    else if (value == "ce")
    {
        return (libpacket::protocol::ipv4::ecn_value::ce);
    }

    return (static_cast<libpacket::protocol::ipv4::ecn_value>(0));
}

static libpacket::type::bit_flags<libpacket::protocol::ipv4::flags_value> to_ipv4_flags(std::vector<std::string>& values)
{
    auto tmp = libpacket::type::bit_flags<libpacket::protocol::ipv4::flags_value>{0};
    for (auto& value : values)
    {
        if (value == "evil_bit")
        {
            tmp |= libpacket::protocol::ipv4::flags_value::evil_bit;
        }
        else if (value == "dont_fragment")
        {
            tmp |= libpacket::protocol::ipv4::flags_value::dont_fragment;
        }
        else if (value == "more_fragments")
        {
            tmp |= libpacket::protocol::ipv4::flags_value::more_fragments;
        }
    }
    return (tmp);
}

libpacket::protocol::ipv4 to_protocol(const std::shared_ptr<swagger::v1::model::PacketProtocolIpv4>& src)
{
    auto dst = libpacket::protocol::ipv4{};

    if (src) {
        if (src->versionIsSet())
        {
            set_ipv4_version(dst, src->getVersion());
        }
        if (src->headerLengthIsSet())
        {
            set_ipv4_header_length(dst, src->getHeaderLength());
        }
        if (src->dscpIsSet())
        {
            set_ipv4_dscp(dst, src->getDscp());
        }
        if (src->ecnIsSet())
        {
            set_ipv4_ecn(dst, to_ipv4_ecn(src->getEcn()));
        }
        if (src->totalLengthIsSet())
        {
            set_ipv4_total_length(dst, src->getTotalLength());
        }
        if (src->identificationIsSet())
        {
            set_ipv4_identification(dst, src->getIdentification());
        }
        if (src->flagsIsSet())
        {
            set_ipv4_flags(dst, to_ipv4_flags(src->getFlags()));
        }
        if (src->fragmentOffsetIsSet())
        {
            set_ipv4_fragment_offset(dst, src->getFragmentOffset());
        }
        if (src->timeToLiveIsSet())
        {
            set_ipv4_time_to_live(dst, src->getTimeToLive());
        }
        if (src->protocolIsSet())
        {
            set_ipv4_protocol(dst, src->getProtocol());
        }
        if (src->checksumIsSet())
        {
            set_ipv4_checksum(dst, src->getChecksum());
        }
        if (src->sourceIsSet())
        {
            set_ipv4_source(dst, libpacket::type::ipv4_address(src->getSource()));
        }
        if (src->destinationIsSet())
        {
            set_ipv4_destination(dst, libpacket::type::ipv4_address(src->getDestination()));
        }
    }

    return (dst);
}

}
