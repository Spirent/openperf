# coding: utf-8

"""
    OpenPerf API

    REST API interface for OpenPerf  # noqa: E501

    OpenAPI spec version: 1
    Contact: support@spirent.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class PacketAnalyzerConfig(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'filter': 'str',
        'protocol_counters': 'list[str]',
        'flow_counters': 'list[str]',
        'flow_digests': 'list[str]'
    }

    attribute_map = {
        'filter': 'filter',
        'protocol_counters': 'protocol_counters',
        'flow_counters': 'flow_counters',
        'flow_digests': 'flow_digests'
    }

    def __init__(self, filter=None, protocol_counters=None, flow_counters=None, flow_digests=None):  # noqa: E501
        """PacketAnalyzerConfig - a model defined in Swagger"""  # noqa: E501

        self._filter = None
        self._protocol_counters = None
        self._flow_counters = None
        self._flow_digests = None
        self.discriminator = None

        if filter is not None:
            self.filter = filter
        self.protocol_counters = protocol_counters
        self.flow_counters = flow_counters
        if flow_digests is not None:
            self.flow_digests = flow_digests

    @property
    def filter(self):
        """Gets the filter of this PacketAnalyzerConfig.  # noqa: E501

        Berkley Packet Filter (BPF) rules that matches input packets for this analyzer to count. An empty rule, the default, matches all frames.   # noqa: E501

        :return: The filter of this PacketAnalyzerConfig.  # noqa: E501
        :rtype: str
        """
        return self._filter

    @filter.setter
    def filter(self, filter):
        """Sets the filter of this PacketAnalyzerConfig.

        Berkley Packet Filter (BPF) rules that matches input packets for this analyzer to count. An empty rule, the default, matches all frames.   # noqa: E501

        :param filter: The filter of this PacketAnalyzerConfig.  # noqa: E501
        :type: str
        """
        self._filter = filter

    @property
    def protocol_counters(self):
        """Gets the protocol_counters of this PacketAnalyzerConfig.  # noqa: E501

        List of protocol counters to update per analyzer for received packets.   # noqa: E501

        :return: The protocol_counters of this PacketAnalyzerConfig.  # noqa: E501
        :rtype: list[str]
        """
        return self._protocol_counters

    @protocol_counters.setter
    def protocol_counters(self, protocol_counters):
        """Sets the protocol_counters of this PacketAnalyzerConfig.

        List of protocol counters to update per analyzer for received packets.   # noqa: E501

        :param protocol_counters: The protocol_counters of this PacketAnalyzerConfig.  # noqa: E501
        :type: list[str]
        """
        self._protocol_counters = protocol_counters

    @property
    def flow_counters(self):
        """Gets the flow_counters of this PacketAnalyzerConfig.  # noqa: E501

        List of results to generate per flow for received packets. Sequencing, latency, and jitter results require Spirent signatures in the received packets. Pseudo Random Bit Sequence (PRBS) results require packet payloads to contain compatible PRBs data.   # noqa: E501

        :return: The flow_counters of this PacketAnalyzerConfig.  # noqa: E501
        :rtype: list[str]
        """
        return self._flow_counters

    @flow_counters.setter
    def flow_counters(self, flow_counters):
        """Sets the flow_counters of this PacketAnalyzerConfig.

        List of results to generate per flow for received packets. Sequencing, latency, and jitter results require Spirent signatures in the received packets. Pseudo Random Bit Sequence (PRBS) results require packet payloads to contain compatible PRBs data.   # noqa: E501

        :param flow_counters: The flow_counters of this PacketAnalyzerConfig.  # noqa: E501
        :type: list[str]
        """
        self._flow_counters = flow_counters

    @property
    def flow_digests(self):
        """Gets the flow_digests of this PacketAnalyzerConfig.  # noqa: E501

        List of result digests to generate per flow for received packets. Sequence run length, latency, and jitter digests require Spirent signatures in the received packets.   # noqa: E501

        :return: The flow_digests of this PacketAnalyzerConfig.  # noqa: E501
        :rtype: list[str]
        """
        return self._flow_digests

    @flow_digests.setter
    def flow_digests(self, flow_digests):
        """Sets the flow_digests of this PacketAnalyzerConfig.

        List of result digests to generate per flow for received packets. Sequence run length, latency, and jitter digests require Spirent signatures in the received packets.   # noqa: E501

        :param flow_digests: The flow_digests of this PacketAnalyzerConfig.  # noqa: E501
        :type: list[str]
        """
        self._flow_digests = flow_digests

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(PacketAnalyzerConfig, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, PacketAnalyzerConfig):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
