#include <array>

#include "catch.hpp"

#include "spirent_pga/api.h"
#include "api_test.h"

TEST_CASE("PRBS functions", "[spirent-pga]")
{
    constexpr uint32_t seed = 0xffffffff;

    SECTION("implementations") {
        auto& functions = pga::functions::instance();
        /*
         * Start by generating scalar PRBS data.  We use it as the basis
         * for all further tests.
         */
        constexpr int buffer_size = 1024;
        std::array<uint32_t, buffer_size> ref_data;
        auto scalar_fn = pga::test::get_function(functions.fill_prbs_aligned_impl,
                                                 pga::instruction_set::type::SCALAR);
        REQUIRE(scalar_fn != nullptr);
        auto ref_next_seed = scalar_fn(ref_data.data(), ref_data.size(), seed);

        SECTION("generation") {
            /*
             * Check that all available PRBS functions generate the same data.
             * We do that by comparing the scalar reference data to what is
             * generated by all of the available vector functions.
             */
            std::array<uint32_t, buffer_size> data;
            unsigned vector_tests = 0;

            for (auto instruction_set : { pga::instruction_set::type::SSE2,
                                          pga::instruction_set::type::SSE4,
                                          pga::instruction_set::type::AVX,
                                          pga::instruction_set::type::AVX2,
                                          pga::instruction_set::type::AVX512SKX }) {

                auto vector_fn = pga::test::get_function(functions.fill_prbs_aligned_impl,
                                                         instruction_set);
                /*
                 * Obviously, we can't test a null function or an instruction set
                 * our CPU won't run.
                 */
                if (!(vector_fn && pga::instruction_set::available(instruction_set))) {
                    continue;
                }

                vector_tests++;
                auto next_seed = vector_fn(data.data(), data.size(), seed);
                REQUIRE(ref_next_seed == next_seed);
                REQUIRE(std::equal(std::begin(ref_data), std::end(ref_data),
                                   std::begin(data)));
            }

            /* We should have at least one vector function, right? */
            REQUIRE(vector_tests > 0);
        }

        SECTION("verification") {
            /*
             * All of our verify functions should return the reference seed,
             * since that's the next seed in the sequence, and 0 bit errors.
             */
            unsigned verify_tests = 0;
            uint64_t verify_result = static_cast<uint64_t>(ref_next_seed) << 32 | 0;

            for (auto instruction_set : { pga::instruction_set::type::SCALAR,
                                          pga::instruction_set::type::SSE2,
                                          pga::instruction_set::type::SSE4,
                                          pga::instruction_set::type::AVX,
                                          pga::instruction_set::type::AVX2,
                                          pga::instruction_set::type::AVX512SKX }) {

                auto verify_fn = pga::test::get_function(functions.verify_prbs_aligned_impl,
                                                         instruction_set);

                if (!(verify_fn && pga::instruction_set::available(instruction_set))) {
                    continue;
                }

                verify_tests++;
                auto result = verify_fn(ref_data.data(), ref_data.size(), ~ref_data[0]);
                REQUIRE(verify_result == result);
            }
            /* scalar + at least 1 vector */
            REQUIRE(verify_tests > 1);
        }
    }

    SECTION("API") {
        /*
         * The API functions handle alignment issues that the aligned vector
         * functions can't handle.  As such, we only really need to make sure
         * alignment cases are handled correctly.  The previous section verified
         * the core implementations.
         */
        constexpr size_t buffer_size = 32;
        std::array<uint8_t, buffer_size> buffer;

        SECTION("unaligned start") {
            for (auto offset : { 1, 2, 3 }) {
                auto ptr = &buffer[offset];
                uint16_t length = buffer_size - offset;

                pga_fill_prbs(&ptr, &length, 1, seed);

                uint32_t bit_errors = 0;
                auto errors = pga_verify_prbs(&ptr, &length, 1, &bit_errors);
                REQUIRE(bit_errors == 0);
                REQUIRE(errors == false);
            }
        }

        SECTION("unaligned end") {
            for (auto offset : { 1, 2, 3 }) {
                auto ptr = buffer.data();
                uint16_t length = buffer_size - offset;

                pga_fill_prbs(&ptr, &length, 1, seed);

                uint32_t bit_errors = 0;
                auto errors = pga_verify_prbs(&ptr, &length, 1, &bit_errors);
                REQUIRE(bit_errors == 0);
                REQUIRE(errors == false);
            }
        }

        SECTION("error detection") {
            /* Make sure we can actually detect bit-errors! */
            auto ptr = buffer.data();
            uint16_t length = buffer_size;

            pga_fill_prbs(&ptr, &length, 1, seed);

            /*
             * Flip a bit.
             * Note: we can't detect errors until we've determined the PRBS
             * sequence, hence error detection in the first 8 bytes is iffy
             */
            buffer[8] ^= 1;

            uint32_t bit_errors = 0;
            auto errors = pga_verify_prbs(&ptr, &length, 1, &bit_errors);
            REQUIRE(bit_errors == 1);
            REQUIRE(errors == true);
        }
    }
}
