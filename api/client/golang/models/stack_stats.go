// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// StackStats Stack statistics
//
// swagger:model StackStats
type StackStats struct {

	// arp
	// Required: true
	Arp *StackProtocolStats `json:"arp"`

	// heap
	// Required: true
	Heap *StackMemoryStats `json:"heap"`

	// icmpv4
	// Required: true
	Icmpv4 *StackProtocolStats `json:"icmpv4"`

	// icmpv6
	// Required: true
	Icmpv6 *StackProtocolStats `json:"icmpv6"`

	// igmp
	// Required: true
	Igmp *StackProtocolStats `json:"igmp"`

	// ipv4
	// Required: true
	IPV4 *StackProtocolStats `json:"ipv4"`

	// ipv4 frag
	// Required: true
	IPV4Frag *StackProtocolStats `json:"ipv4_frag"`

	// ipv6
	// Required: true
	IPV6 *StackProtocolStats `json:"ipv6"`

	// ipv6 frag
	// Required: true
	IPV6Frag *StackProtocolStats `json:"ipv6_frag"`

	// mboxes
	// Required: true
	Mboxes *StackElementStats `json:"mboxes"`

	// mld
	// Required: true
	Mld *StackProtocolStats `json:"mld"`

	// mutexes
	// Required: true
	Mutexes *StackElementStats `json:"mutexes"`

	// nd
	// Required: true
	Nd *StackProtocolStats `json:"nd"`

	// pools
	// Required: true
	Pools []*StackMemoryStats `json:"pools"`

	// sems
	// Required: true
	Sems *StackElementStats `json:"sems"`

	// tcp
	// Required: true
	TCP *StackProtocolStats `json:"tcp"`

	// udp
	// Required: true
	UDP *StackProtocolStats `json:"udp"`
}

// Validate validates this stack stats
func (m *StackStats) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateArp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIcmpv4(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIcmpv6(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIgmp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV4(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV4Frag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV6(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV6Frag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMboxes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMld(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMutexes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePools(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTCP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUDP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StackStats) validateArp(formats strfmt.Registry) error {

	if err := validate.Required("arp", "body", m.Arp); err != nil {
		return err
	}

	if m.Arp != nil {
		if err := m.Arp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("arp")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateHeap(formats strfmt.Registry) error {

	if err := validate.Required("heap", "body", m.Heap); err != nil {
		return err
	}

	if m.Heap != nil {
		if err := m.Heap.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("heap")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateIcmpv4(formats strfmt.Registry) error {

	if err := validate.Required("icmpv4", "body", m.Icmpv4); err != nil {
		return err
	}

	if m.Icmpv4 != nil {
		if err := m.Icmpv4.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("icmpv4")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateIcmpv6(formats strfmt.Registry) error {

	if err := validate.Required("icmpv6", "body", m.Icmpv6); err != nil {
		return err
	}

	if m.Icmpv6 != nil {
		if err := m.Icmpv6.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("icmpv6")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateIgmp(formats strfmt.Registry) error {

	if err := validate.Required("igmp", "body", m.Igmp); err != nil {
		return err
	}

	if m.Igmp != nil {
		if err := m.Igmp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igmp")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateIPV4(formats strfmt.Registry) error {

	if err := validate.Required("ipv4", "body", m.IPV4); err != nil {
		return err
	}

	if m.IPV4 != nil {
		if err := m.IPV4.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipv4")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateIPV4Frag(formats strfmt.Registry) error {

	if err := validate.Required("ipv4_frag", "body", m.IPV4Frag); err != nil {
		return err
	}

	if m.IPV4Frag != nil {
		if err := m.IPV4Frag.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipv4_frag")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateIPV6(formats strfmt.Registry) error {

	if err := validate.Required("ipv6", "body", m.IPV6); err != nil {
		return err
	}

	if m.IPV6 != nil {
		if err := m.IPV6.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipv6")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateIPV6Frag(formats strfmt.Registry) error {

	if err := validate.Required("ipv6_frag", "body", m.IPV6Frag); err != nil {
		return err
	}

	if m.IPV6Frag != nil {
		if err := m.IPV6Frag.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipv6_frag")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateMboxes(formats strfmt.Registry) error {

	if err := validate.Required("mboxes", "body", m.Mboxes); err != nil {
		return err
	}

	if m.Mboxes != nil {
		if err := m.Mboxes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mboxes")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateMld(formats strfmt.Registry) error {

	if err := validate.Required("mld", "body", m.Mld); err != nil {
		return err
	}

	if m.Mld != nil {
		if err := m.Mld.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mld")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateMutexes(formats strfmt.Registry) error {

	if err := validate.Required("mutexes", "body", m.Mutexes); err != nil {
		return err
	}

	if m.Mutexes != nil {
		if err := m.Mutexes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mutexes")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateNd(formats strfmt.Registry) error {

	if err := validate.Required("nd", "body", m.Nd); err != nil {
		return err
	}

	if m.Nd != nil {
		if err := m.Nd.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nd")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validatePools(formats strfmt.Registry) error {

	if err := validate.Required("pools", "body", m.Pools); err != nil {
		return err
	}

	for i := 0; i < len(m.Pools); i++ {
		if swag.IsZero(m.Pools[i]) { // not required
			continue
		}

		if m.Pools[i] != nil {
			if err := m.Pools[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pools" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StackStats) validateSems(formats strfmt.Registry) error {

	if err := validate.Required("sems", "body", m.Sems); err != nil {
		return err
	}

	if m.Sems != nil {
		if err := m.Sems.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sems")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateTCP(formats strfmt.Registry) error {

	if err := validate.Required("tcp", "body", m.TCP); err != nil {
		return err
	}

	if m.TCP != nil {
		if err := m.TCP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) validateUDP(formats strfmt.Registry) error {

	if err := validate.Required("udp", "body", m.UDP); err != nil {
		return err
	}

	if m.UDP != nil {
		if err := m.UDP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("udp")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this stack stats based on the context it is used
func (m *StackStats) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateArp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIcmpv4(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIcmpv6(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIgmp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV4(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV4Frag(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV6(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV6Frag(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMboxes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMld(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMutexes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNd(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePools(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTCP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUDP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StackStats) contextValidateArp(ctx context.Context, formats strfmt.Registry) error {

	if m.Arp != nil {
		if err := m.Arp.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("arp")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateHeap(ctx context.Context, formats strfmt.Registry) error {

	if m.Heap != nil {
		if err := m.Heap.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("heap")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateIcmpv4(ctx context.Context, formats strfmt.Registry) error {

	if m.Icmpv4 != nil {
		if err := m.Icmpv4.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("icmpv4")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateIcmpv6(ctx context.Context, formats strfmt.Registry) error {

	if m.Icmpv6 != nil {
		if err := m.Icmpv6.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("icmpv6")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateIgmp(ctx context.Context, formats strfmt.Registry) error {

	if m.Igmp != nil {
		if err := m.Igmp.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igmp")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateIPV4(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV4 != nil {
		if err := m.IPV4.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipv4")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateIPV4Frag(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV4Frag != nil {
		if err := m.IPV4Frag.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipv4_frag")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateIPV6(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV6 != nil {
		if err := m.IPV6.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipv6")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateIPV6Frag(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV6Frag != nil {
		if err := m.IPV6Frag.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipv6_frag")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateMboxes(ctx context.Context, formats strfmt.Registry) error {

	if m.Mboxes != nil {
		if err := m.Mboxes.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mboxes")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateMld(ctx context.Context, formats strfmt.Registry) error {

	if m.Mld != nil {
		if err := m.Mld.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mld")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateMutexes(ctx context.Context, formats strfmt.Registry) error {

	if m.Mutexes != nil {
		if err := m.Mutexes.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mutexes")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateNd(ctx context.Context, formats strfmt.Registry) error {

	if m.Nd != nil {
		if err := m.Nd.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nd")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidatePools(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Pools); i++ {

		if m.Pools[i] != nil {
			if err := m.Pools[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pools" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StackStats) contextValidateSems(ctx context.Context, formats strfmt.Registry) error {

	if m.Sems != nil {
		if err := m.Sems.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sems")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateTCP(ctx context.Context, formats strfmt.Registry) error {

	if m.TCP != nil {
		if err := m.TCP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp")
			}
			return err
		}
	}

	return nil
}

func (m *StackStats) contextValidateUDP(ctx context.Context, formats strfmt.Registry) error {

	if m.UDP != nil {
		if err := m.UDP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("udp")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *StackStats) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StackStats) UnmarshalBinary(b []byte) error {
	var res StackStats
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
