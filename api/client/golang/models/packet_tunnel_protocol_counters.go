// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PacketTunnelProtocolCounters Tunnel protocol counters
//
// swagger:model PacketTunnelProtocolCounters
type PacketTunnelProtocolCounters struct {

	// Number of IP Encapsulating Security Payload packets
	// Required: true
	// Minimum: 0
	Esp *int64 `json:"esp"`

	// Number of Generic Network Virtualization Encapsulation packets
	// Required: true
	// Minimum: 0
	Geneve *int64 `json:"geneve"`

	// Number of Generic Routing Encapsulation packets
	// Required: true
	// Minimum: 0
	Gre *int64 `json:"gre"`

	// Number of Teredo, VXLAN, or GRE packets on limited hardware
	// Required: true
	// Minimum: 0
	Grenat *int64 `json:"grenat"`

	// Number of GPRS Tunneling Protocol control packets
	// Required: true
	// Minimum: 0
	Gtpc *int64 `json:"gtpc"`

	// Number of GPRS Tunneling Protocol user packets
	// Required: true
	// Minimum: 0
	Gtpu *int64 `json:"gtpu"`

	// Number of IP in IP packets
	// Required: true
	// Minimum: 0
	IP *int64 `json:"ip"`

	// Number of Layer 2 Tunneling Protocol packets
	// Required: true
	// Minimum: 0
	L2tp *int64 `json:"l2tp"`

	// Number of MPLS-in-GRE packets (RFC 4023)
	// Required: true
	// Minimum: 0
	MplsInGre *int64 `json:"mpls_in_gre"`

	// Number of MPLS-in-UDP packets (RFC 7510)
	// Required: true
	// Minimum: 0
	MplsInUDP *int64 `json:"mpls_in_udp"`

	// Number of Network Virtualization using GRE packets
	// Required: true
	// Minimum: 0
	Nvgre *int64 `json:"nvgre"`

	// Number of Virtual eXtensible LAN packets
	// Required: true
	// Minimum: 0
	Vxlan *int64 `json:"vxlan"`

	// Number of VXLAN Generic Protocol Extension packets
	// Required: true
	// Minimum: 0
	VxlanGpe *int64 `json:"vxlan_gpe"`
}

// Validate validates this packet tunnel protocol counters
func (m *PacketTunnelProtocolCounters) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEsp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeneve(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGre(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGrenat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGtpc(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGtpu(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateL2tp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMplsInGre(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMplsInUDP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNvgre(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVxlan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVxlanGpe(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PacketTunnelProtocolCounters) validateEsp(formats strfmt.Registry) error {

	if err := validate.Required("esp", "body", m.Esp); err != nil {
		return err
	}

	if err := validate.MinimumInt("esp", "body", *m.Esp, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateGeneve(formats strfmt.Registry) error {

	if err := validate.Required("geneve", "body", m.Geneve); err != nil {
		return err
	}

	if err := validate.MinimumInt("geneve", "body", *m.Geneve, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateGre(formats strfmt.Registry) error {

	if err := validate.Required("gre", "body", m.Gre); err != nil {
		return err
	}

	if err := validate.MinimumInt("gre", "body", *m.Gre, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateGrenat(formats strfmt.Registry) error {

	if err := validate.Required("grenat", "body", m.Grenat); err != nil {
		return err
	}

	if err := validate.MinimumInt("grenat", "body", *m.Grenat, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateGtpc(formats strfmt.Registry) error {

	if err := validate.Required("gtpc", "body", m.Gtpc); err != nil {
		return err
	}

	if err := validate.MinimumInt("gtpc", "body", *m.Gtpc, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateGtpu(formats strfmt.Registry) error {

	if err := validate.Required("gtpu", "body", m.Gtpu); err != nil {
		return err
	}

	if err := validate.MinimumInt("gtpu", "body", *m.Gtpu, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateIP(formats strfmt.Registry) error {

	if err := validate.Required("ip", "body", m.IP); err != nil {
		return err
	}

	if err := validate.MinimumInt("ip", "body", *m.IP, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateL2tp(formats strfmt.Registry) error {

	if err := validate.Required("l2tp", "body", m.L2tp); err != nil {
		return err
	}

	if err := validate.MinimumInt("l2tp", "body", *m.L2tp, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateMplsInGre(formats strfmt.Registry) error {

	if err := validate.Required("mpls_in_gre", "body", m.MplsInGre); err != nil {
		return err
	}

	if err := validate.MinimumInt("mpls_in_gre", "body", *m.MplsInGre, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateMplsInUDP(formats strfmt.Registry) error {

	if err := validate.Required("mpls_in_udp", "body", m.MplsInUDP); err != nil {
		return err
	}

	if err := validate.MinimumInt("mpls_in_udp", "body", *m.MplsInUDP, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateNvgre(formats strfmt.Registry) error {

	if err := validate.Required("nvgre", "body", m.Nvgre); err != nil {
		return err
	}

	if err := validate.MinimumInt("nvgre", "body", *m.Nvgre, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateVxlan(formats strfmt.Registry) error {

	if err := validate.Required("vxlan", "body", m.Vxlan); err != nil {
		return err
	}

	if err := validate.MinimumInt("vxlan", "body", *m.Vxlan, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketTunnelProtocolCounters) validateVxlanGpe(formats strfmt.Registry) error {

	if err := validate.Required("vxlan_gpe", "body", m.VxlanGpe); err != nil {
		return err
	}

	if err := validate.MinimumInt("vxlan_gpe", "body", *m.VxlanGpe, 0, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this packet tunnel protocol counters based on context it is used
func (m *PacketTunnelProtocolCounters) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PacketTunnelProtocolCounters) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PacketTunnelProtocolCounters) UnmarshalBinary(b []byte) error {
	var res PacketTunnelProtocolCounters
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
