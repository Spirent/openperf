// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MemoryGeneratorConfig Memory generator configuration
//
// swagger:model MemoryGeneratorConfig
type MemoryGeneratorConfig struct {

	// Memory size constraint. The buffer can never be larger than the value specified (in bytes)
	// Required: true
	// Minimum: 64
	BufferSize *int64 `json:"buffer_size"`

	// IO access pattern
	// Required: true
	// Enum: [random sequential reverse]
	Pattern *string `json:"pattern"`

	// Number of bytes to use for each read operation
	// Required: true
	// Minimum: 0
	ReadSize *int64 `json:"read_size"`

	// Number of read worker threads
	// Required: true
	// Minimum: 0
	ReadThreads *int64 `json:"read_threads"`

	// Number of read operations to perform per second
	// Required: true
	// Minimum: 0
	ReadsPerSec *int64 `json:"reads_per_sec"`

	// Number of bytes to use for each write operation
	// Required: true
	// Minimum: 0
	WriteSize *int64 `json:"write_size"`

	// Number of write worker threads
	// Required: true
	// Minimum: 0
	WriteThreads *int64 `json:"write_threads"`

	// Number of write operations to perform per second
	// Required: true
	// Minimum: 0
	WritesPerSec *int64 `json:"writes_per_sec"`
}

// Validate validates this memory generator config
func (m *MemoryGeneratorConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBufferSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePattern(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReadSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReadThreads(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReadsPerSec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWriteSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWriteThreads(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWritesPerSec(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MemoryGeneratorConfig) validateBufferSize(formats strfmt.Registry) error {

	if err := validate.Required("buffer_size", "body", m.BufferSize); err != nil {
		return err
	}

	if err := validate.MinimumInt("buffer_size", "body", *m.BufferSize, 64, false); err != nil {
		return err
	}

	return nil
}

var memoryGeneratorConfigTypePatternPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["random","sequential","reverse"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		memoryGeneratorConfigTypePatternPropEnum = append(memoryGeneratorConfigTypePatternPropEnum, v)
	}
}

const (

	// MemoryGeneratorConfigPatternRandom captures enum value "random"
	MemoryGeneratorConfigPatternRandom string = "random"

	// MemoryGeneratorConfigPatternSequential captures enum value "sequential"
	MemoryGeneratorConfigPatternSequential string = "sequential"

	// MemoryGeneratorConfigPatternReverse captures enum value "reverse"
	MemoryGeneratorConfigPatternReverse string = "reverse"
)

// prop value enum
func (m *MemoryGeneratorConfig) validatePatternEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, memoryGeneratorConfigTypePatternPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MemoryGeneratorConfig) validatePattern(formats strfmt.Registry) error {

	if err := validate.Required("pattern", "body", m.Pattern); err != nil {
		return err
	}

	// value enum
	if err := m.validatePatternEnum("pattern", "body", *m.Pattern); err != nil {
		return err
	}

	return nil
}

func (m *MemoryGeneratorConfig) validateReadSize(formats strfmt.Registry) error {

	if err := validate.Required("read_size", "body", m.ReadSize); err != nil {
		return err
	}

	if err := validate.MinimumInt("read_size", "body", *m.ReadSize, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *MemoryGeneratorConfig) validateReadThreads(formats strfmt.Registry) error {

	if err := validate.Required("read_threads", "body", m.ReadThreads); err != nil {
		return err
	}

	if err := validate.MinimumInt("read_threads", "body", *m.ReadThreads, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *MemoryGeneratorConfig) validateReadsPerSec(formats strfmt.Registry) error {

	if err := validate.Required("reads_per_sec", "body", m.ReadsPerSec); err != nil {
		return err
	}

	if err := validate.MinimumInt("reads_per_sec", "body", *m.ReadsPerSec, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *MemoryGeneratorConfig) validateWriteSize(formats strfmt.Registry) error {

	if err := validate.Required("write_size", "body", m.WriteSize); err != nil {
		return err
	}

	if err := validate.MinimumInt("write_size", "body", *m.WriteSize, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *MemoryGeneratorConfig) validateWriteThreads(formats strfmt.Registry) error {

	if err := validate.Required("write_threads", "body", m.WriteThreads); err != nil {
		return err
	}

	if err := validate.MinimumInt("write_threads", "body", *m.WriteThreads, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *MemoryGeneratorConfig) validateWritesPerSec(formats strfmt.Registry) error {

	if err := validate.Required("writes_per_sec", "body", m.WritesPerSec); err != nil {
		return err
	}

	if err := validate.MinimumInt("writes_per_sec", "body", *m.WritesPerSec, 0, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this memory generator config based on context it is used
func (m *MemoryGeneratorConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MemoryGeneratorConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MemoryGeneratorConfig) UnmarshalBinary(b []byte) error {
	var res MemoryGeneratorConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
