// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BlockGeneratorConfig Block generator configuration
//
// swagger:model BlockGeneratorConfig
type BlockGeneratorConfig struct {

	// IO access pattern
	// Required: true
	// Enum: [random sequential reverse]
	Pattern *string `json:"pattern"`

	// Number of simultaneous (asynchronous) operations
	// Required: true
	// Minimum: 1
	QueueDepth *int64 `json:"queue_depth"`

	// ratio
	Ratio *BlockGeneratorConfigRatio `json:"ratio,omitempty"`

	// Number of bytes to use for each read operation
	// Required: true
	// Minimum: 1
	ReadSize *int64 `json:"read_size"`

	// Number of read operations to perform per second
	// Required: true
	// Minimum: 0
	ReadsPerSec *int64 `json:"reads_per_sec"`

	// Number of bytes to use for each write operation
	// Required: true
	// Minimum: 1
	WriteSize *int64 `json:"write_size"`

	// Number of write operations to perform per second
	// Required: true
	// Minimum: 0
	WritesPerSec *int64 `json:"writes_per_sec"`
}

// Validate validates this block generator config
func (m *BlockGeneratorConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePattern(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueueDepth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRatio(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReadSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReadsPerSec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWriteSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWritesPerSec(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var blockGeneratorConfigTypePatternPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["random","sequential","reverse"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		blockGeneratorConfigTypePatternPropEnum = append(blockGeneratorConfigTypePatternPropEnum, v)
	}
}

const (

	// BlockGeneratorConfigPatternRandom captures enum value "random"
	BlockGeneratorConfigPatternRandom string = "random"

	// BlockGeneratorConfigPatternSequential captures enum value "sequential"
	BlockGeneratorConfigPatternSequential string = "sequential"

	// BlockGeneratorConfigPatternReverse captures enum value "reverse"
	BlockGeneratorConfigPatternReverse string = "reverse"
)

// prop value enum
func (m *BlockGeneratorConfig) validatePatternEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, blockGeneratorConfigTypePatternPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BlockGeneratorConfig) validatePattern(formats strfmt.Registry) error {

	if err := validate.Required("pattern", "body", m.Pattern); err != nil {
		return err
	}

	// value enum
	if err := m.validatePatternEnum("pattern", "body", *m.Pattern); err != nil {
		return err
	}

	return nil
}

func (m *BlockGeneratorConfig) validateQueueDepth(formats strfmt.Registry) error {

	if err := validate.Required("queue_depth", "body", m.QueueDepth); err != nil {
		return err
	}

	if err := validate.MinimumInt("queue_depth", "body", *m.QueueDepth, 1, false); err != nil {
		return err
	}

	return nil
}

func (m *BlockGeneratorConfig) validateRatio(formats strfmt.Registry) error {
	if swag.IsZero(m.Ratio) { // not required
		return nil
	}

	if m.Ratio != nil {
		if err := m.Ratio.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ratio")
			}
			return err
		}
	}

	return nil
}

func (m *BlockGeneratorConfig) validateReadSize(formats strfmt.Registry) error {

	if err := validate.Required("read_size", "body", m.ReadSize); err != nil {
		return err
	}

	if err := validate.MinimumInt("read_size", "body", *m.ReadSize, 1, false); err != nil {
		return err
	}

	return nil
}

func (m *BlockGeneratorConfig) validateReadsPerSec(formats strfmt.Registry) error {

	if err := validate.Required("reads_per_sec", "body", m.ReadsPerSec); err != nil {
		return err
	}

	if err := validate.MinimumInt("reads_per_sec", "body", *m.ReadsPerSec, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *BlockGeneratorConfig) validateWriteSize(formats strfmt.Registry) error {

	if err := validate.Required("write_size", "body", m.WriteSize); err != nil {
		return err
	}

	if err := validate.MinimumInt("write_size", "body", *m.WriteSize, 1, false); err != nil {
		return err
	}

	return nil
}

func (m *BlockGeneratorConfig) validateWritesPerSec(formats strfmt.Registry) error {

	if err := validate.Required("writes_per_sec", "body", m.WritesPerSec); err != nil {
		return err
	}

	if err := validate.MinimumInt("writes_per_sec", "body", *m.WritesPerSec, 0, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this block generator config based on the context it is used
func (m *BlockGeneratorConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRatio(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BlockGeneratorConfig) contextValidateRatio(ctx context.Context, formats strfmt.Registry) error {

	if m.Ratio != nil {
		if err := m.Ratio.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ratio")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BlockGeneratorConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BlockGeneratorConfig) UnmarshalBinary(b []byte) error {
	var res BlockGeneratorConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BlockGeneratorConfigRatio BlockGeneratorReadWriteRatio
//
// Relative amount of a mixed workload operations that should be performed. If value is not given, ratio is not limited.
//
// swagger:model BlockGeneratorConfigRatio
type BlockGeneratorConfigRatio struct {

	// reads
	// Minimum: 1
	Reads int64 `json:"reads,omitempty"`

	// writes
	// Minimum: 1
	Writes int64 `json:"writes,omitempty"`
}

// Validate validates this block generator config ratio
func (m *BlockGeneratorConfigRatio) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateReads(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWrites(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BlockGeneratorConfigRatio) validateReads(formats strfmt.Registry) error {
	if swag.IsZero(m.Reads) { // not required
		return nil
	}

	if err := validate.MinimumInt("ratio"+"."+"reads", "body", m.Reads, 1, false); err != nil {
		return err
	}

	return nil
}

func (m *BlockGeneratorConfigRatio) validateWrites(formats strfmt.Registry) error {
	if swag.IsZero(m.Writes) { // not required
		return nil
	}

	if err := validate.MinimumInt("ratio"+"."+"writes", "body", m.Writes, 1, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this block generator config ratio based on context it is used
func (m *BlockGeneratorConfigRatio) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *BlockGeneratorConfigRatio) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BlockGeneratorConfigRatio) UnmarshalBinary(b []byte) error {
	var res BlockGeneratorConfigRatio
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
