// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SpirentSignature Configures Spirent test signature
//
// swagger:model SpirentSignature
type SpirentSignature struct {

	// fill
	Fill *SpirentSignatureFill `json:"fill,omitempty"`

	// Indicates timestamp offset
	// Required: true
	// Enum: [start_of_frame end_of_frame]
	Latency *string `json:"latency"`

	// Stream IDs are created for each flow of the definition. This
	// property specifies the ID to use for the first flow. Subsequent
	// flows will use incremented IDs. For example, if a traffic
	// definitions contains 20 flows with a first_stream_id value of
	// 1, then the definition will use 1-20 for stream ids.
	//
	// Required: true
	StreamID *int32 `json:"stream_id"`
}

// Validate validates this spirent signature
func (m *SpirentSignature) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFill(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreamID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SpirentSignature) validateFill(formats strfmt.Registry) error {
	if swag.IsZero(m.Fill) { // not required
		return nil
	}

	if m.Fill != nil {
		if err := m.Fill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fill")
			}
			return err
		}
	}

	return nil
}

var spirentSignatureTypeLatencyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["start_of_frame","end_of_frame"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		spirentSignatureTypeLatencyPropEnum = append(spirentSignatureTypeLatencyPropEnum, v)
	}
}

const (

	// SpirentSignatureLatencyStartOfFrame captures enum value "start_of_frame"
	SpirentSignatureLatencyStartOfFrame string = "start_of_frame"

	// SpirentSignatureLatencyEndOfFrame captures enum value "end_of_frame"
	SpirentSignatureLatencyEndOfFrame string = "end_of_frame"
)

// prop value enum
func (m *SpirentSignature) validateLatencyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, spirentSignatureTypeLatencyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SpirentSignature) validateLatency(formats strfmt.Registry) error {

	if err := validate.Required("latency", "body", m.Latency); err != nil {
		return err
	}

	// value enum
	if err := m.validateLatencyEnum("latency", "body", *m.Latency); err != nil {
		return err
	}

	return nil
}

func (m *SpirentSignature) validateStreamID(formats strfmt.Registry) error {

	if err := validate.Required("stream_id", "body", m.StreamID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this spirent signature based on the context it is used
func (m *SpirentSignature) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFill(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SpirentSignature) contextValidateFill(ctx context.Context, formats strfmt.Registry) error {

	if m.Fill != nil {
		if err := m.Fill.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fill")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SpirentSignature) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SpirentSignature) UnmarshalBinary(b []byte) error {
	var res SpirentSignature
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SpirentSignatureFill Specifies optional packet payload fill
//
// swagger:model SpirentSignatureFill
type SpirentSignatureFill struct {

	// Constant, repeating fill value for payload
	// Maximum: 65535
	// Minimum: 0
	Constant *int32 `json:"constant,omitempty"`

	// Decrement octet values for payload
	// Maximum: 255
	// Minimum: 0
	Decrement *int32 `json:"decrement,omitempty"`

	// Increment octet values for payload
	// Maximum: 255
	// Minimum: 0
	Increment *int32 `json:"increment,omitempty"`

	// Use pseudo random bit sequence for payload
	Prbs bool `json:"prbs,omitempty"`
}

// Validate validates this spirent signature fill
func (m *SpirentSignatureFill) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConstant(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDecrement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIncrement(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SpirentSignatureFill) validateConstant(formats strfmt.Registry) error {
	if swag.IsZero(m.Constant) { // not required
		return nil
	}

	if err := validate.MinimumInt("fill"+"."+"constant", "body", int64(*m.Constant), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("fill"+"."+"constant", "body", int64(*m.Constant), 65535, false); err != nil {
		return err
	}

	return nil
}

func (m *SpirentSignatureFill) validateDecrement(formats strfmt.Registry) error {
	if swag.IsZero(m.Decrement) { // not required
		return nil
	}

	if err := validate.MinimumInt("fill"+"."+"decrement", "body", int64(*m.Decrement), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("fill"+"."+"decrement", "body", int64(*m.Decrement), 255, false); err != nil {
		return err
	}

	return nil
}

func (m *SpirentSignatureFill) validateIncrement(formats strfmt.Registry) error {
	if swag.IsZero(m.Increment) { // not required
		return nil
	}

	if err := validate.MinimumInt("fill"+"."+"increment", "body", int64(*m.Increment), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("fill"+"."+"increment", "body", int64(*m.Increment), 255, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this spirent signature fill based on context it is used
func (m *SpirentSignatureFill) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SpirentSignatureFill) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SpirentSignatureFill) UnmarshalBinary(b []byte) error {
	var res SpirentSignatureFill
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
