// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PacketCaptureConfig Packet capture configuration; the configuration controls the capture
// behavior.
//
//
// swagger:model packetCaptureConfig
type PacketCaptureConfig struct {

	// Capture buffer size in bytes.
	// Required: true
	// Minimum: 4096
	BufferSize *int64 `json:"buffer_size"`

	// Indicates whether capture wraps when it reaches the end of the
	// buffer.  When buffer wrap is enabled capture will continue until
	// capture is stopped with the stop command or a stop trigger.
	//
	BufferWrap *bool `json:"buffer_wrap,omitempty"`

	// Maximum time duration for the capture in msec.
	//
	// Minimum: 1
	Duration int64 `json:"duration,omitempty"`

	// Berkley Packet Filter (BPF) rules that matches packets to
	// capture.  An empty rule, the default, matches all frames.
	//
	Filter string `json:"filter,omitempty"`

	// Capture mode
	// Required: true
	// Enum: [buffer live]
	Mode *string `json:"mode"`

	// Maximum number of packets to capture.
	//
	// Minimum: 1
	PacketCount int64 `json:"packet_count,omitempty"`

	// Maximum length of packet to capture. If the packet is larger than the packet size, the packet is truncated.
	// Minimum: 1
	PacketSize int32 `json:"packet_size,omitempty"`

	// Berkley Packet Filter (BPF) rules used to trigger the start
	// of packet capture.  When a trigger condition is specified,
	// the capture start command puts capture into an armed state
	// and capture will only begin when the trigger condition occurs.
	//
	StartTrigger string `json:"start_trigger,omitempty"`

	// Berkley Packet Filter (BPF) rules used to trigger the stop
	// of packet capture.
	//
	StopTrigger string `json:"stop_trigger,omitempty"`
}

// Validate validates this packet capture config
func (m *PacketCaptureConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBufferSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePacketCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePacketSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PacketCaptureConfig) validateBufferSize(formats strfmt.Registry) error {

	if err := validate.Required("buffer_size", "body", m.BufferSize); err != nil {
		return err
	}

	if err := validate.MinimumInt("buffer_size", "body", *m.BufferSize, 4096, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketCaptureConfig) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	if err := validate.MinimumInt("duration", "body", m.Duration, 1, false); err != nil {
		return err
	}

	return nil
}

var packetCaptureConfigTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["buffer","live"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		packetCaptureConfigTypeModePropEnum = append(packetCaptureConfigTypeModePropEnum, v)
	}
}

const (

	// PacketCaptureConfigModeBuffer captures enum value "buffer"
	PacketCaptureConfigModeBuffer string = "buffer"

	// PacketCaptureConfigModeLive captures enum value "live"
	PacketCaptureConfigModeLive string = "live"
)

// prop value enum
func (m *PacketCaptureConfig) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, packetCaptureConfigTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PacketCaptureConfig) validateMode(formats strfmt.Registry) error {

	if err := validate.Required("mode", "body", m.Mode); err != nil {
		return err
	}

	// value enum
	if err := m.validateModeEnum("mode", "body", *m.Mode); err != nil {
		return err
	}

	return nil
}

func (m *PacketCaptureConfig) validatePacketCount(formats strfmt.Registry) error {
	if swag.IsZero(m.PacketCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("packet_count", "body", m.PacketCount, 1, false); err != nil {
		return err
	}

	return nil
}

func (m *PacketCaptureConfig) validatePacketSize(formats strfmt.Registry) error {
	if swag.IsZero(m.PacketSize) { // not required
		return nil
	}

	if err := validate.MinimumInt("packet_size", "body", int64(m.PacketSize), 1, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this packet capture config based on context it is used
func (m *PacketCaptureConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PacketCaptureConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PacketCaptureConfig) UnmarshalBinary(b []byte) error {
	var res PacketCaptureConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
